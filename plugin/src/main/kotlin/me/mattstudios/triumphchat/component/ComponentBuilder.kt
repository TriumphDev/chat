package me.mattstudios.triumphchat.component

import me.mattstudios.msg.adventure.AdventureSerializer
import me.mattstudios.msg.base.internal.action.HoverMessageAction
import me.mattstudios.msg.base.internal.action.MessageAction
import me.mattstudios.msg.base.internal.action.content.HoverContent
import me.mattstudios.msg.base.internal.nodes.MessageNode
import me.mattstudios.msg.base.internal.nodes.TextNode
import me.mattstudios.triumphchat.api.ChatPlayer
import me.mattstudios.triumphchat.config.bean.objects.FormatDisplay
import me.mattstudios.triumphchat.config.bean.objects.elements.ClickData
import me.mattstudios.triumphchat.func.parseMarkdown
import me.mattstudios.triumphchat.func.parsePAPI
import net.kyori.adventure.text.Component

/**
 * This is likely not final, until I figure how I would make this using adventure's builder instead
 * Issues are because of how I handle the extensions
 */
class ComponentBuilder {

    private val finalNodes = mutableListOf<MessageNode>()
    private val currentNodes = mutableListOf<MessageNode>()

    /**
     * Appends a string, hover, and click
     */
    fun append(
        text: String,
        hover: List<String>?,
        click: ClickData?,
        sender: ChatPlayer?,
        recipient: ChatPlayer?
    ): ComponentBuilder {
        return append(text.parsePAPI(sender, recipient).parseMarkdown(), hover, click, sender, recipient)
    }

    /**
     * Appends specifically message nodes generated by the message lib
     */
    fun append(
        nodes: List<MessageNode>,
        hover: List<String>?,
        click: ClickData?,
        sender: ChatPlayer?,
        recipient: ChatPlayer?
    ): ComponentBuilder {
        currentNodes.addAll(nodes)
        hover?.let { addHover(it.joinToString("\\n") { text -> text.parsePAPI(sender, recipient) }) }
        click?.let { addClick(it, sender, recipient) }
        return this
    }

    /**
     * Appends a config component
     */
    fun append(display: FormatDisplay, player: ChatPlayer?, recipient: ChatPlayer?): ComponentBuilder {
        return append(display.text, display.hover, display.click, player, recipient)
    }

    /**
     * Creates the final Kyori component
     */
    fun build(): Component {
        save()
        return AdventureSerializer.toComponent(finalNodes)
    }

    /**
     * Adds hover action to the current nodes
     */
    private fun addHover(hover: String) {
        if (hover.isEmpty()) return
        addAction(HoverMessageAction(HoverContent.showText(hover.parseMarkdown())))
    }

    /**
     * Adds a click action to the current nodes
     */
    private fun addClick(click: ClickData, sender: ChatPlayer?, recipient: ChatPlayer?) {
        with(click) {
            if (isNotEmpty) return
            //addAction(ClickMessageAction(action, finalValue.parsePAPI(sender, recipient)))
        }
    }

    /**
     * Adds the action to all current nodes
     */
    private fun addAction(action: MessageAction) {
        /*currentNodes.filterIsInstance(TextNode::class.java)
                .filter { it.actions == null || it.actions?.filterIsInstance(action.javaClass)?.isEmpty() == true }
                .forEach {
                    addAction(it, action)
                }*/
    }

    /**
     * Adds a action to the nodes
     */
    private fun addAction(node: TextNode, action: MessageAction) {
        if (node.actions == null) {
            node.actions = mutableListOf(action)
            return
        }

        node.actions?.add(action)
    }

    /**
     * Saves the current nodes into the final nodes so the next append won't be affected
     */
    private fun save() {
        if (currentNodes.isEmpty()) return
        finalNodes.addAll(currentNodes.toList())
        currentNodes.clear()
    }

}