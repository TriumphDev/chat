package me.mattstudios.triumphchat.component

import me.mattstudios.mfmsg.adventure.AdventureSerializer
import me.mattstudios.mfmsg.base.MessageOptions
import me.mattstudios.mfmsg.base.internal.Format
import me.mattstudios.mfmsg.base.internal.action.ClickMessageAction
import me.mattstudios.mfmsg.base.internal.action.HoverMessageAction
import me.mattstudios.mfmsg.base.internal.action.MessageAction
import me.mattstudios.mfmsg.base.internal.action.content.HoverContent
import me.mattstudios.mfmsg.base.internal.color.FlatColor
import me.mattstudios.mfmsg.base.internal.color.MessageColor
import me.mattstudios.mfmsg.base.internal.components.MessageNode
import me.mattstudios.mfmsg.base.internal.components.TextNode
import me.mattstudios.mfmsg.base.internal.parser.MarkdownParser
import me.mattstudios.triumphchat.config.bean.objects.Click
import me.mattstudios.triumphchat.config.bean.objects.FormatComponent
import me.mattstudios.triumphchat.func.GLOBAL_MESSAGE
import me.mattstudios.triumphchat.func.parsePAPI
import net.kyori.adventure.text.Component
import org.bukkit.entity.Player

class ChatComponentBuilder {

    private val finalNodes = mutableListOf<MessageNode>()
    private val currentNodes = mutableListOf<MessageNode>()

    /**
     * Appends a string, hover, and click
     */
    fun append(text: String, hover: List<String>? = null, click: Click? = null, player: Player): ChatComponentBuilder {
        append(text.parsePAPI(player))
        hover?.let { addHover(it.joinToString("\\n") { text -> text.parsePAPI(player) }) }
        click?.let { addClick(it, player) }
        return this
    }

    /**
     * Appends specifically message nodes generated by the message lib
     */
    fun append(
        nodes: List<MessageNode>,
        hover: List<String>? = null,
        click: Click? = null,
        player: Player
    ): ChatComponentBuilder {
        currentNodes.addAll(nodes)
        hover?.let { addHover(it.joinToString("\\n") { text -> text.parsePAPI(player) }) }
        click?.let { addClick(it, player) }
        return this
    }

    /**
     * Appends a config component
     */
    fun append(component: FormatComponent, player: Player): ChatComponentBuilder {
        return append(component.text, component.formatHover, component.formatClick, player)
    }

    /**
     * Creates the final Kyory component
     */
    fun build(): Component {
        save()
        return AdventureSerializer.toComponent(finalNodes)
    }

    /**
     * Appends a normal text by generating it's nodes from the lib, required to parse markdown from the config
     */
    fun append(
        message: String,
        formats: Set<Format> = Format.ALL,
        defaultColor: MessageColor = FlatColor("white")
    ): ChatComponentBuilder {
        save()
        currentNodes.addAll(
            MarkdownParser(
                MessageOptions.builder(formats).setDefaultColor(defaultColor).build()
            ).parse(message)
        )
        return this
    }

    /**
     * Adds hover action to the current nodes
     */
    private fun addHover(hover: String) {
        if (hover.isEmpty()) return
        currentNodes.filterIsInstance(TextNode::class.java).forEach {
            addAction(it, HoverMessageAction(HoverContent.showText(GLOBAL_MESSAGE.parseToNodes(hover))))
        }
    }

    /**
     * Adds a click action to the current nodes
     */
    private fun addClick(click: Click, player: Player) {
        var value = click.value
        val formatType = click.getFormat()

        if (formatType == null || value == null) return

        if (!value.startsWith('/')) value = "/$value"
        addClick(formatType, value.parsePAPI(player))
    }

    /**
     * Adds the click action generated before to the current nodes
     */
    private fun addClick(type: Format, value: String) {
        currentNodes.filterIsInstance(TextNode::class.java).forEach {
            val clickAction = ClickMessageAction(type, value)
            if (it.actions == null) {
                it.actions = mutableListOf<MessageAction>(clickAction)
            } else {
                it.actions?.add(clickAction)
            }
        }
    }

    /**
     * Adds a action to the nodes
     */
    private fun addAction(node: TextNode, action: MessageAction) {
        if (node.actions == null) {
            node.actions = mutableListOf(action)
        } else {
            node.actions?.add(action)
        }
    }

    /**
     * Saves the current nodes into the final nodes so the next append won't be affected
     */
    private fun save() {
        if (currentNodes.isEmpty()) return
        finalNodes.addAll(currentNodes.toList())
        currentNodes.clear()
    }

}